<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Compile-time programming in C++20 and beyond</title>
    <meta name="author" content="Louis Dionne">

    <link rel="stylesheet" href="reveal/css/reveal.css">
    <link rel="stylesheet" href="reveal/css/theme/black.css">
    <link rel="stylesheet" href="plugin/line-numbers.css">
    <link rel="stylesheet" href="custom.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="highlight-styles/vs2015.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown=""
                 data-separator="^====+$"
                 data-separator-vertical="^----+$"
                 data-notes="^Note:">
        <script type="text/template">

## Compile-time programming in C++20 and beyond
#### Louis Dionne, Apple

<!-- TODO:
  - At all times, make it clear what is expected for C++20 and what isn't
  - Mention compilation speed improvements over TMP
  - Talk about Immediate functions / `constexpr!`
-->

====

- These slides are available at: https://ldionne.com/cppcon-2018-compile-time-programming
- Their source code is available at: https://github.com/ldionne/cppcon-2018-compile-time-programming

====

<!-- .slide: class="slide-hidden" -->

### Font test

```c++
class ThisIsAClass {

};

int main() {
  // this is a comment
  std::vector<Foobar> foobar;

  foobar.push_back(Foo{...});
  foobar.push_back(Bar{...});
  foobar.push_back(Baz{...});

  for (auto& x : foobar) {
    x.do_something();
  }
}
```

==============================================================================

### Why do we care about compile-time programming?

====

### Constant initialization

```c++
// Lookup table for e^i with i in [0, 1000]
constexpr std::array<double, 1001> exps = compute_exp(0, 1000);

int main() {
  int i = read_from_user();
  std::cout << exps[i] << std::endl;
}
```

Note:
- No static initialization
- Hardcoded in the data segment

====

### Defining flexible APIs

```c++
template <typename T>
std::string to_json(T const& t) {
  std::string result = "{";
  for (auto member : members_of(t)) { // not valid today!
    result += member.name();
    result += ":";
    result += to_json(member.value());
    result += ",";
  }
  result += "}";
  return result;
}

struct Foo {
  int x;
  float y;
  double z;
};

std::string json = to_json(Foo{1, 2.2f, 3.3});
```

Note:
This is indeed compile-time programming since the members are known at
compile-time. This wouldn't be a "real" for-loop.

====

### Boilerplate reduction

```c++
enum class Color { RED, GREEN, BLUE, YELLOW, PURPLE };

std::ostream& operator<<(std::ostream& out, Color color) {
  switch (color) {
    case Color::RED:    out << "RED";    break;
    case Color::GREEN:  out << "GREEN";  break;
    case Color::BLUE:   out << "BLUE";   break;
    case Color::YELLOW: out << "YELLOW"; break;
    case Color::PURPLE: out << "PURPLE"; break;
  }
  return out;
}

int main() {
  Color color = read_from_user();
  std::cout << color << std::endl;
}
```

====

### Seriously, who has seen this code?

==============================================================================

### Solving these problems used to be a nerdy topic

Even among C++ programmers :-)

====

### Now all the cool kids are on it

- Standard containers and constexpr: [p0784](http://wg21.link/p0784)
- Making `std::vector` constexpr: [p1004](http://wg21.link/p1004)
- Making `<algorithm>` constexpr: [p0202](http://wg21.link/p0202) & friends
- `std::is_constant_evaluated()`: [p0595](http://wg21.link/p0595)
- `constexpr!` functions: [p1073](http://wg21.link/p1073)
- The Reflection TS: [n4746](http://wg21.link/n4746)
- Metaclasses: [p0707](http://wg21.link/p0707)
- Value-based reflection: [p0993](http://wg21.link/p0993)
- Calling virtual functions in `constexpr`: [p1064](http://wg21.link/p1064)
- `try-catch` in constexpr: [p1002](http://wg21.link/p1002)
<!-- - Mental model for compile-time programming: [p0992](http://wg21.link/p0992) -->
<!-- - Class Types in Non-Type Template Parameters: [p0732](http://wg21.link/p0732) -->

====

### This can be hard to follow

Even committee members are confused

====

### So, what's the plan?

1. Make (almost) all of C++ available in `constexpr`
2. Provide a `constexpr` API to _query_ the compiler
3. Provide a means for modifying the AST

Note:
This is C++ kid, there's no plan!

==============================================================================

### Step 1: Expanding `constexpr`

Necessary in order to use non-trivial data structures and execute non-trivial
logic at compile-time.

====

#### In C++11, `constexpr` was very limited

- Functions with a single return statement

====

#### In C++14, many restrictions lifted

- Loops
- `if` statements
- variables can be modified
- lambdas can be used
- etc...

====

#### In C++17, `constexpr` is still limited

- No allocations
- No try-catch
- No virtual calls
- No `reinterpret_cast`

====

This means we can't use variable-size containers

```c++
template <typename Predicate>
constexpr std::vector<int>
filter(int* it, int* last, Predicate pred) {
  std::vector<int> result;
  for (; it != last; ++it) {
    if (pred(*it)) {
      result.push_back(*it);
    }
  }
  return result;
}

constexpr int ints[] = {1, 2, 3, 4, 5, 6};
constexpr std::vector<int> odds =
                      filter(begin(ints), end(ints), is_odd);
// doesn't work!
```

====

We have to use fixed-size arrays, which is painful

```c++
template <std::size_t K, typename Predicate>
constexpr std::array<int, K>
filter(int* it, int* last, Predicate pred) {
  std::array<int, K> result;
  int* out = begin(result);
  for (; it != last; ++it) {
    if (pred(*it)) {
      *out++ = *it;
    }
  }
  return result;
}

constexpr int ints[] = {1, 2, 3, 4, 5, 6};
constexpr std::array<int, 3> odds =
                      filter<3>(begin(ints), end(ints), is_odd);
```

Note:
Problem is that we don't know the size of the output sequence in advance.

====

#### Constexpr algorithms don't compose well

====

### Enter [p0784](http://wg21.link/p0784)

- Enables new expressions in `constexpr`
- Makes `std::allocator` usable in `constexpr`
- Promotes some `constexpr` objects to static storage

====

#### The following becomes valid

```c++
constexpr int* square(int* first, int* last) {
  std::size_t N = last - first;
  int* result = new int[N]; // <== HERE
  for (std::size_t i = 0; i != N; ++i, ++first) {
    result[i] = *first * *first;
  }
  return result;
}

constexpr void hello() {
  int ints[] = {1, 2, 3, 4, 5};
  int* squared = square(std::begin(ints), std::end(ints));
  delete[] squared;
}
```

====

### Obvious next step

Make `std::vector` constexpr

====

#### But `std::vector` uses try-catch

So make try-catch constexpr!

Note:
Try-catch is used to provide the strong exception guarantee in case the
underlying operation fails.

====

### Enter [p1002](http://wg21.link/p1002)

```c++
template <std::size_t N>
constexpr std::array<int, N>
square(std::array<int, N> array, int from, int to) {
  try {
    for (; from != to; ++from) {
      array.at(from) = array.at(from) * array.at(from);
    }
  } catch (std::out_of_range const& e) {
    // handle that
  }
  return array;
}

constexpr auto OK     = square(std::array{1, 2, 3, 4}, 0, 4);
constexpr auto NOT_OK = square(std::array{1, 2, 3, 4}, 0, 10);
```

====

### But it's not as cool as you think

`throw` is still not allowed

====

This works because we never execute a `throw` statement:

```c++
constexpr auto OK = square(std::array{1, 2, 3, 4}, 0, 4);
```

====

This fails when we execute the `throw` inside `array::at`:

```c++
constexpr auto NOT_OK = square(std::array{1, 2, 3, 4}, 0, 10);
```

====

We're never given the chance to handle the exception

Note:
Implementing full EH at compile-time is tricky -- compiler has to unwind the
stack, etc..

====

In the future, we can extend the language

====

### Back to `std::vector`

In C++20, this will just work:

```c++
template <typename Predicate>
constexpr std::vector<int>
filter(int* it, int* last, Predicate pred) {
  std::vector<int> result;
  for (; it != last; ++it) {
    if (pred(*it)) {
      result.push_back(*it);
    }
  }
  return result;
}

constexpr std::vector<int> ints = {1, 2, 3, 4, 5, 6};
constexpr std::vector<int> odds =
                      filter(begin(ints), end(ints), is_odd);
```

====

### Promotion to static storage

Also called non-transient allocations

====

#### What happens with this code?
Where is `table` stored?

```c++
constexpr std::vector<int> table = compute_table();

int main(int argc, char* argv[]) {
  int from = std::atoi(argv[1]);
  int to = std::atoi(argv[2]);
  for (; from != to; ++from) {
    std::cout << table[from] << std::endl;
  }
}
```

====

#### Answer: promoted to static storage

- If a constexpr object "leaks" from compile-time
- And its destructor would clean up if it were called
- Then it is promoted to static storage

====

### That's really nothing new

Here, `table` will be in the data segment

```c++
constexpr std::array<int, 4> table = {1, 2, 3, 4};

int main(int argc, char* argv[]) {
  int from = std::atoi(argv[1]);
  int to = std::atoi(argv[2]);
  for (; from != to; ++from) {
    std::cout << table[from] << std::endl;
  }
}
```

====

If the destructor would not clean up, then it's not a constant expression

====

#### Corollary
If you can evaluate a function call in a constant expression, then that
function call is leak-free for the provided inputs.

====

The compiler turns into a leak detector!

====

### Future constexpr additions

- `std::string`
- `std::map` and `std::unordered_map`
- `std::optional`/`std::variant`?
- Math functions?
- Almost everything? Join the effort!

====

### Challenges

- `reinterpret_cast` (e.g. `std::string` SBO)
- non-constexpr builtins (e.g. `__builtin_memcpy`)
- Raw memory allocation (e.g. `malloc`)
- Other annotations (e.g. UBSan in libc++)

====

### Aside: why no `reinterpret_cast`?

- Compiler has to catch UB inside `constexpr`
- Otherwise the compilation itself is UB and you get an arbitrary program
- `reinterpret_cast` makes UB difficult to catch

====

### Aside: why no raw allocation?

- Similar problem as `reinterpret_cast`
- Compiler hands you an arbitrary chunk of memory
- Trusts you to initialize and manage lifetime properly
- Otherwise, UB during compilation

====

### Why is this a problem?

====

`constexpr` means "this _can_ be executed at compile-time", not
"this _must_ be executed at compile-time"

====

This means most `constexpr` functions should be usable both at compile-time
and at runtime

====

We don't want to pessimize good runtime C++ code

====

### Enter [p0595](http://wg21.link/p0595)

- Adds `std::is_constant_evaluated()`
- Allows detecting whether the current function is evaluated as part
  of a constant expression

====

### For example

```c++
template <typename T>
void vector<T>::clear() noexcept {
  size_t old_size = size();
  // ...
  __annotate_shrink(old_size); // ASAN annotation
  __invalidate_all_iterators(); // Debug mode checks
}
```

====

### Making this constexpr

```c++
template <typename T>
constexpr void vector<T>::clear() noexcept {
  size_t old_size = size();
  // ...
  if (!std::is_constant_evaluated()) {
    __annotate_shrink(old_size); // ASAN annotation
    __invalidate_all_iterators(); // Debug mode checks
  }
}
```

====

### How this works

```c++
constexpr int f() {
  std::vector<int> v = {1, 2, 3};
  v.clear();
  return 0;
}

constexpr int X = f(); // is_constant_evaluated() true, no annotations
int Y = f(); // is_constant_evaluated() false, normal runtime code
```

====

### Summary

- Expand `constexpr` to support more use cases
- Allow persisting data structures to the _data segment_
- Allow writing different code for `constexpr` and runtime when needed

==============================================================================

### Step 2: an API to speak to the compiler

====

### Basically, extract information about types

====

### We can already do some of it

- type_traits
- operators like `sizeof`

```c++
struct Foo {
  int x;
  int y;
};

constexpr std::size_t size = sizeof(Foo);
constexpr bool is_aggregate = std::is_aggregate_v<Foo>;
```

====

### But we're severely limited

```c++
struct Foo {
  int x;
  int y;
};

constexpr auto members = ???; // list of Foo's members
```

====

### We lack:

- A way to query many properties
- A way to represent the answer to those queries

====

### Enter the Reflection TS: [n4746](http://wg21.link/n4746)

====

### Purpose:

- Figure out what this query API should look like
- Not the specific implementation of this API
- For now, the API uses template metaprogramming

====

### Example: extracting members

```c++
struct Foo {
  int x;
  int y;
};

using MetaFoo = reflexpr(Foo);

using Members = std::reflect::get_data_members_t<MetaFoo>;

using X = std::reflect::get_element_t<0, Members>; // Not an int!

constexpr bool is_public = std::reflect::is_public_v<X>;

using TypeOfX = std::reflect::get_reflected_type_t<X>; // This is int!
```

Note:
- `reflexpr(Foo)` is a magic type representing `Foo` in the compiler
- `Members` is a magic type satisfying the `ObjectSequence` concept.
- `X` is a magic type representing `Foo::x`

====

### Other features:
- Get source line/column of a type definition
- Get the name of an entity as a string
- Get member types/enums/etc of a type
- Get base classes of a type
- Get enumerators of an enum
- Get whether variable is `static`/`constexpr`
- Get properties of base classes: `virtual`/`public`/etc

<!-- TODO: Consider adding examples for those features -->

====

### More features planned in the future
- Reflecting functions: [p0670](http://wg21.link/p0670)
- Plans to reflect on arbitrary expressions too!!!

<!-- TODO: Consider adding examples for those features -->

====

### Final syntax not settled yet: [p0953](http://wg21.link/p0953)

```c++
template <typename T>
void dump() {
  constexpr std::reflect::Record const* metaT = reflexpr(T);
  std::cout << "name: " << metaT->get_display_name() << std::endl;
  std::cout << "members:" << std::endl;
  for(RecordMember const* member : metaT->get_public_data_members()) {
      std::cout << member->get_type()->get_display_name() << ' '
                << member->get_name() << std::endl;
  }
}

struct Foo {
  int x;
  long y;
  float z;
};

int main() {
  dump<Foo>();
}
```

====

### Summary

1. Reflection TS figures out the compiler query API
2. Will rebase on top of the constexpr work
3. Aim is to write normal-looking C++ code

==============================================================================

### Step 3: Code generation

====

### So far, we can:

1. Write complex compile-time algorithms
2. Query the compiler AST

====

### Now: modify the compiler's AST

====

### Alternatives on the table:

1. Raw string injection
2. Programmatic API
3. Token-sequence injection

====

### Raw string injection ([p0633](http://wg21.link/p0633))

```c++
template <HashAlgorithm H, SimpleStruct S>
void hash_append(H& h, S const& s) {
  constexpr {
    for (meta::info member : meta::data_members(reflexpr(s))) {
      meta::queue(
        meta::code("hash_append(h, s.", meta::name(member), ");")
      );
    }
  }
}
```

====

### Programmatic API ([p0633](http://wg21.link/p0633))

```c++
template <HashAlgorithm H, SimpleStruct S>
void hash_append(H& h, S const& s) {
  constexpr {
    for (meta::info member : meta::data_members(reflexpr(s))) {
      meta::queue(meta::expr_statement(
        meta::call_by_name(
          "hash_append",
          reflexpr(h),
          meta::select_member(reflexpr(s), member))));
    }
  }
}
```

====

### Token-sequence injection ([p0633](http://wg21.link/p0633))

```c++
template <HashAlgorithm H, SimpleStruct S>
void hash_append(H& h, S const& s) {
  constexpr {
    for (meta::info member : meta::data_members(reflexpr(s))) {
      -> { hash_append(h, s.(.member.)); }
    }
  }
}
```

====

### What about metaclasses ([p0707](http://wg21.link/p0707))?

```c++
constexpr void interface(meta::type target, meta::type const source) {
  for (auto f : source.functions()) {
    if (!f.has_access())
      f.make_public();
    f.make_pure_virtual();
    ->(target) f;
  }
  ->(target) { virtual ~(source.name()$)() noexcept {} }
}

interface Shape { // MAGIC!!!
  int area() const;
  void scale_by(double factor);
};
```

====

### Metaclasses are built on top of code generation

They're not a replacement for it

====

### Summary

- Provide a way to influence the AST
- Multiple options on the table
- Should interact nicely with `constexpr` control flow
- Metaclasses? Maybe, but it's an orthogonal problem

====

### What can we hope for?

__This is just my optimistic prediction, not a promise!__

====

### C++20

- More `constexpr`:
  + `std::vector`, `std::string`, `std::map`
  + language features required by those
- `<experimental/reflect>` (syntax not determined)

====

### C++23

- Even more `constexpr`: where do we stop?
- Some code generation mechanism
- `<experimental/reflect>` based on `constexpr`
  + just `<reflect>` if we're lucky

====

### This will change the face of C++

====

### This opens endless possibilities

- For incredible libraries
- For code reuse
- For interoperation with other languages
- To shoot oneself in the foot

Note:
The Committee will tread carefully because a mistake in how these features
are designed could make them useless or downright harmful.

====

### With great power comes great...

### C++ programs!!! <!-- .element: class="fragment" -->

====

### Thank you

https://ldionne.com

        </script>
        </section>
      </div>
    </div>

    <script src="js/jquery-3.2.1.min.js"></script>
    <script src="reveal/js/reveal.js"></script>
    <script src="reveal/lib/js/head.min.js"></script>

    <script>
      Reveal.initialize({
        slideNumber: 'c', // 'c/t' -> useful when authoring to know how many slides there are
        history: true,
        transition: 'none',
        controlsTutorial: false,

        // Default settings for charts embedded in the presentation
        chart: {
          defaults: {
            global: {
              responsive: true,
              animation: null,
              title: { fontColor: "#FFF" },
              legend: {
                labels: {
                  fontColor: "#FFF",
                  fontSize: 20
                }
              }
            },
            scale: {
              scaleLabel: { fontColor: "#FFF" },
              gridLines: { color: "#FFF", zeroLineColor: "#FFF" },
              ticks: { fontColor: "#FFF" }
            }
          }
        },

        dependencies: [
          { src: 'reveal/plugin/markdown/marked.js' },
          { src: 'reveal/plugin/markdown/markdown.js' },
          { src: 'reveal/plugin/notes/notes.js', async: true },
          { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/line-numbers.js'}
        ]
      });

      // Remove all DOM elements with the 'slide-hidden' class. This allows
      // statically marking slides as hidden to exclude them from the
      // presentation.
      Reveal.addEventListener('ready', function(event) {
        $(".slide-hidden").each(function(index, slide) {
          slide.remove();
        });
      });

      // Add the line-numbers class to all code blocks, so that code examples
      // have line numbers.
      Reveal.addEventListener('ready', function(event) {
        $("pre>code").each(function(index, block) {
          block.classList.add("line-numbers");
        });
      });
    </script>
  </body>
</html>
